import React, { useState } from 'react'
import _ from 'lodash'

import { useTheme } from "@material-ui/core/styles";

import {
    Grid,
    Paper,
    Typography,
    Button,
    Select,
    MenuItem,
    Accordion,
    AccordionSummary,
    AccordionDetails,
    FormControl,
    FormHelperText,
} from '@material-ui/core/index'

import ExpandMoreIcon from '@material-ui/icons/ExpandMore';
import ExpandLessIcon from '@material-ui/icons/ExpandLess';

import useMediaQuery from '@material-ui/core/useMediaQuery'

import Node from './util/Node'
import dict from './words.json'
import worker from 'workerize-loader?inline!./util/allPathsWorker' // eslint-disable-line import/no-webpack-loader-syntax

import useStyles from './style'

import InputGrid from './components/InputGrid/InputGrid'
import ResultBar from './components/ResultBar/ResultBar';

const Main = () => {

    const classes = useStyles()
    const theme = useTheme()
    const isPortraitDevice = useMediaQuery('(max-aspect-ratio: 11/10)')

    // State
    const [gridWidth, setGridWidth] = useState(4)
    const [gridHeight, setGridHeight] = useState(4)
    const [inputs, setInputs] = useState(Array(gridHeight).fill().map(() => Array(gridWidth).fill('')))
    const [dictName, setDictName] = useState('built in')
    const [dictionary, setDictionary] = useState(dict)
    const [minWordLength, setMinWordLength] = useState(3)

    const [warningText, setWarningText] = useState('')
    const [showOptionsPanel, setShowOptionsPanel] = useState(false)
    const [processing, setProcessing] = useState(false)
    const [foundWords, setFoundWords] = useState([])

    const [highlightWord, setHighlightWord] = useState('')
    const [highlightPath, setHighlightPath] = useState([])


    function clearResults() {
        setFoundWords({})
    }

    function setBoardSize(size) {
        setGridWidth(size)
        setGridHeight(size)
        setInputs(Array(size).fill().map(() => Array(size).fill('')))
        clearResults()
    }

    function handlePaths(paths) {
        const results = paths
            .map(path => ({
                'string': path.map(node => node.value || node._value).join(''),
                'path': path.map(node => node.id || node._id)
            })
            )

        const uniqResults = _.uniqBy(results, 'string')
        const groupedResults = _.groupBy(uniqResults, ({ string }) => string.length)

        for (const key of Object.keys(groupedResults)) {
            groupedResults[key] = _.orderBy(groupedResults[key], ['string'], ['asc'])
        }

        setFoundWords(groupedResults)
    }

    function checkValidInput(str) {
        return str.match(/^([A-Z]|QU)$/g)
    }

    function findWords(inputGrid) {
        setProcessing(true)
        const graph = Node.graphFromGrid(inputGrid)

        const workerInstances = Array(gridWidth * gridHeight).fill().map(() => new worker())

        const promises = workerInstances.map((worker, i) => new Promise((resolve, reject) => {
            worker.addEventListener('message', ({ data }) => {
                if (data.type !== "RPC") {
                    // Non-autogenerated control events
                    resolve(data)
                }
            })

            worker.workerPathsFrom(graph[i],
                { minWordLength, dictionary }
            )
        }))

        Promise.all(promises)
            .then(results => results.reduce((acc, val) => acc.concat(val), []))
            .then(handlePaths)
            .then(() => setProcessing(false))

    }

    function runHighlightAnimation(path, onFinish) {
        const animInterval = 200
        const holdOnEnd = 1000

        let pathIndex = 0

        const animId = setInterval(() => {
            if (pathIndex >= path.length) {
                clearInterval(animId)
                setTimeout(() => {
                    setHighlightPath([])
                    onFinish()
                }, holdOnEnd)
                return
            }

            setHighlightPath(prev => [...prev, path[pathIndex]])
            pathIndex++

        }, animInterval)
    }

    return (
        <div>
            <div className={classes.topBar}>
                <Typography
                    variant="h4"
                    className={classes.title}
                >
                    Boggle-Bot
                </Typography>
            </div>
            <Grid
                className={classes.content}
                container
                spacing={2}
            >
                <Grid item xs={isPortraitDevice ? 12 : 8}>
                    <Paper className={`${classes.paper} ${classes.inputGridPaper}`}>
                        <InputGrid
                            values={inputs}
                            checkValidInput={checkValidInput}
                            highlights={highlightPath}
                            onChange={(i, j, newValue) => {
                                let stateClone = _.cloneDeep(inputs)
                                stateClone[i][j] = newValue.toUpperCase()
                                setInputs(stateClone)
                                clearResults()
                            }}
                        />
                        <div className={classes.controlPanel}>
                            <Button
                                variant='contained'
                                color='primary'
                                disabled={processing}
                                onClick={() => {
                                    if (!inputs.every(row => row.every(item => checkValidInput(item)))) {
                                        setWarningText('Please fill in grid correctly')
                                        return
                                    }
                                    findWords(inputs)
                                }}>
                                Find Words
                            </Button>
                            <Typography color='error'>
                                {warningText}
                            </Typography>
                            <div className={classes.optionsPanel}>
                                <div
                                    style={{ cursor: 'pointer', display: 'inline-block' }}
                                    onClick={() => setShowOptionsPanel(prev => !prev)}
                                >
                                    <Typography style={{ display: 'inline-block', verticalAlign: 'middle' }}>
                                        {showOptionsPanel ? 'Hide options' : 'Show options'}
                                    </Typography>
                                    {showOptionsPanel
                                        ? <ExpandLessIcon style={{ display: 'inline-block', verticalAlign: 'middle' }} />
                                        : <ExpandMoreIcon style={{ display: 'inline-block', verticalAlign: 'middle' }} />
                                    }
                                </div>
                                {showOptionsPanel && (
                                    <Paper className={`${classes.paper} ${classes.optionsPanel}`}>
                                        <FormControl className={classes.control}>
                                            <Select
                                                value={gridWidth}
                                                onChange={e => {
                                                    setBoardSize(e.target.value)
                                                }}
                                            >
                                                <MenuItem value={2}>2</MenuItem>
                                                <MenuItem value={3}>3</MenuItem>
                                                <MenuItem value={4}>4</MenuItem>
                                                <MenuItem value={5}>5</MenuItem>
                                                <MenuItem value={6}>6</MenuItem>
                                            </Select>
                                            <FormHelperText>Grid size</FormHelperText>
                                        </FormControl>
                                        <FormControl className={classes.control}>
                                            <Select
                                                value={minWordLength}
                                                onChange={e => {
                                                    setMinWordLength(e.target.value)
                                                    clearResults()
                                                }}
                                            >
                                                <MenuItem value={1}>1</MenuItem>
                                                <MenuItem value={2}>2</MenuItem>
                                                <MenuItem value={3}>3</MenuItem>
                                                <MenuItem value={4}>4</MenuItem>
                                                <MenuItem value={5}>5</MenuItem>
                                            </Select>
                                            <FormHelperText>Minimum word length</FormHelperText>
                                        </FormControl>
                                        <input
                                            accept='text/*'
                                            className={classes.input}
                                            id='dictionary-upload'
                                            multiple
                                            type='file'
                                            hidden
                                            onChange={({ target }) => {
                                                const fr = new FileReader()
                                                fr.readAsText(target.files[0])
                                                fr.onload = (e) => {
                                                    setDictionary(e.target.result.split('\n'))
                                                    setDictName(target.files[0].name)
                                                    clearResults()
                                                }
                                            }}
                                        />
                                        <label htmlFor='dictionary-upload'>
                                            <FormControl className={classes.control}>
                                                <Button color='primary' component='span'>
                                                    Upload custom dictionary
                                                </Button>
                                                <FormHelperText
                                                    style={{ paddingLeft: theme.spacing(1), paddingRight: theme.spacing(1)}}
                                                >
                                                    {`Current dictionary: ${dictName}`}
                                                </FormHelperText>
                                            </FormControl>
                                        </label>
                                    </Paper>
                                )}
                            </div>
                        </div>
                    </Paper>
                </Grid>
                <Grid item xs={isPortraitDevice ? 12 : 4}>
                    <Paper className={classes.paper}>
                        {
                            <Typography variant='h4'>
                                {
                                    processing ? 'Finding words...'
                                        : _.isEmpty(foundWords)
                                            ? 'Fill in grid to begin'
                                            : `${Object.entries(foundWords).reduce((acc, [wordLen, words]) => acc + words.length, 0)} Words Found`
                                }
                            </Typography>
                        }
                        {
                            Object.entries(foundWords).length > 0 &&
                            (<div className={classes.resultsBox}>
                                {
                                    Object.entries(foundWords).reverse().map(([wordLen, words]) => (
                                        <Accordion key={`${wordLen}-accordion`} >
                                            <AccordionSummary
                                                expandIcon={<ExpandMoreIcon />}
                                                aria-controls={`${wordLen}-letter-content`}
                                                id={`${wordLen}-letter-header`}
                                            >
                                                <Typography variant='h5'>{`${wordLen}-letter words`}</Typography>
                                            </AccordionSummary>
                                            <AccordionDetails style={{ display: 'block' }}>
                                                {words.map(({ string, path }) =>
                                                    <ResultBar
                                                        key={string}
                                                        word={string}
                                                        isHighlighting={highlightWord === string}
                                                        canHighlight={highlightWord === ''}
                                                        onHighlight={() => {
                                                            setHighlightWord(string)
                                                            if (isPortraitDevice) {
                                                                window.scrollTo(0, 0)
                                                            }
                                                            runHighlightAnimation(path,
                                                                () => setHighlightWord(''))
                                                        }}
                                                    />
                                                )}
                                            </AccordionDetails>
                                        </Accordion>
                                    ))
                                }
                            </div>)
                        }
                    </Paper>
                </Grid>

            </Grid>

        </div>
    )
}

export default Main
